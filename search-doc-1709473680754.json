{"searchDocs":[{"title":"Changelog","type":0,"sectionRef":"#","url":"/docs/changelog-and-roadmap","content":"","keywords":"","version":null},{"title":"@react-native-documents/picker​","type":1,"pageTitle":"Changelog","url":"/docs/changelog-and-roadmap#react-native-documentspicker","content":" 10.0.0​  Initial release. We're starting with version 10.0.0 to continue the series from the react-native-document-picker library.  ","version":null,"tagName":"h3"},{"title":"@react-native-documents/picker​","type":1,"pageTitle":"Changelog","url":"/docs/changelog-and-roadmap#react-native-documentspicker-1","content":" 1.0.0​  Initial release  Roadmap  What are the upcoming features and improvements for the project?   bringing Viewer module out of beta isKnownType for Android handling stale bookmark data add new options to pick, such as for showing file extensions on iOS and more bridgeless mode support for more Predefined File Types out of the box keepLocalCopy for open mode api and error codes improvements documentation improvements macOS support ","version":null,"tagName":"h3"},{"title":"Jest module mocks","type":0,"sectionRef":"#","url":"/docs/jest-mocks","content":"Jest module mocks You will need to mock the functionality of the native modules once you require them from your test files. We provide Jest mocks that you can add to the setupFiles array in the Jest config. By default, the mocks behave as if the calls were successful and return mock document data. { &quot;setupFiles&quot;: [ &quot;./node_modules/@react-native-documents/picker/jest/build/jest/setup.js&quot;, &quot;./node_modules/@react-native-documents/viewer/jest/build/jest/setup.js&quot; ] } ","keywords":"","version":null},{"title":"Other libraries","type":0,"sectionRef":"#","url":"/docs/other-libs","content":"","keywords":"","version":null},{"title":"react-native-theme-control​","type":1,"pageTitle":"Other libraries","url":"/docs/other-libs#react-native-theme-control","content":" Natively control react native application theme at runtime and persist it for the next app start.  ","version":null,"tagName":"h3"},{"title":"react-navigation-header-buttons​","type":1,"pageTitle":"Other libraries","url":"/docs/other-libs#react-navigation-header-buttons","content":" Easily render header buttons for react-navigation.  ","version":null,"tagName":"h3"},{"title":"react-to-imperative​","type":1,"pageTitle":"Other libraries","url":"/docs/other-libs#react-to-imperative","content":" Convert React (Native) components for imperative use.  ","version":null,"tagName":"h3"},{"title":"react-native-datetimepicker​","type":1,"pageTitle":"Other libraries","url":"/docs/other-libs#react-native-datetimepicker","content":" React Native date &amp; time picker component for iOS and Android.  ","version":null,"tagName":"h3"},{"title":"JS-lingui​","type":1,"pageTitle":"Other libraries","url":"/docs/other-libs#js-lingui","content":" A readable, automated, and optimized internationalization for JavaScript.  ","version":null,"tagName":"h3"},{"title":"react-native-google-signin​","type":1,"pageTitle":"Other libraries","url":"/docs/other-libs#react-native-google-signin","content":" Google Sign In for React Native. ","version":null,"tagName":"h3"},{"title":"Migrating from the old document-picker","type":0,"sectionRef":"#","url":"/docs/migration","content":"","keywords":"","version":null},{"title":"Migrating your code​","type":1,"pageTitle":"Migrating from the old document-picker","url":"/docs/migration#migrating-your-code","content":" Good news: most of the api is the same. You need to make only a few changes:  update import statements  import { ... } from 'react-native-document-picker'   becomes  import { ... } from '@react-native-documents/picker'   remove pickSingle  Replace pickSingle with pick:  const result = await pickSingle(options)   becomes:  const [result] = await pick(options)   replace copyTo with keepLocalCopy  This change makes your app more responsive: previously you'd use the copyTo option and before the returned Promise resolved, you needed to wait not only for the user to pick the file, but also for the file to be copied to your app's directory. For large files or with slow network, this could be a problem that you, as a dev don't see, but your users do.  const localCopy = await pick({ copyTo: 'documentDirectory', })   becomes  const [file] = await pick() const [localCopy] = await keepLocalCopy({ files: [ { uri: file.uri, fileName: file.name ?? 'fallbackName', }, ], destination: 'documentDirectory', })  ","version":null,"tagName":"h3"},{"title":"Directory Picker","type":0,"sectionRef":"#","url":"/docs/picker/directory-picker","content":"","keywords":"","version":null},{"title":"How it works​","type":1,"pageTitle":"Directory Picker","url":"/docs/picker/directory-picker#how-it-works","content":"     AndroidiOS Open mode uses Intent.ACTION_OPEN_DOCUMENT_TREE internally. ","version":null,"tagName":"h3"},{"title":"Document Viewer API","type":0,"sectionRef":"#","url":"/docs/doc-viewer-api","content":"","keywords":"","version":null},{"title":"Type Aliases​","type":1,"pageTitle":"Document Viewer API","url":"/docs/doc-viewer-api#type-aliases","content":" ","version":null,"tagName":"h2"},{"title":"OptionsViewBookmark​","type":1,"pageTitle":"Document Viewer API","url":"/docs/doc-viewer-api#optionsviewbookmark","content":" Ƭ OptionsViewBookmark: Object  Type declaration​  Name\tType\tDescriptionbookmark\tstring\tbookmark data from the DocumentPicker module. Obtain it using the &quot;open&quot; mode, with requestLongTermAccess flag set to true. A bookmark allows a long-term permission to access a file. grantPermissions?\t&quot;read&quot; | &quot;write&quot;\tAndroid only: The type of permission to grant to the receiving app that will open the document. NOTE: this is experimental and may not work as expected. The functionality will be improved in a future release. headerTitle?\tstring\tiOS only: The title to display in the header of the document viewer if not provided, the filename will be used    ","version":null,"tagName":"h3"},{"title":"OptionsViewUri​","type":1,"pageTitle":"Document Viewer API","url":"/docs/doc-viewer-api#optionsviewuri","content":" Ƭ OptionsViewUri: Object  Type declaration​  Name\tType\tDescriptiongrantPermissions?\t&quot;read&quot; | &quot;write&quot;\tAndroid only: The type of permission to grant to the receiving app that will open the document. NOTE: this is experimental and may not work as expected. The functionality will be improved in a future release. headerTitle?\tstring\tiOS only: The title to display in the header of the document viewer if not provided, the filename will be used uri\tstring\tThe uri of the document to view    ","version":null,"tagName":"h3"},{"title":"ViewDocumentOptions​","type":1,"pageTitle":"Document Viewer API","url":"/docs/doc-viewer-api#viewdocumentoptions","content":" Ƭ ViewDocumentOptions: OptionsViewBookmark | OptionsViewUri  options for viewing a document  If you're trying to open a file that you have long-term permission to access, you should use the bookmark option (provided by the DocumentPicker module).  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Document Viewer API","url":"/docs/doc-viewer-api#functions","content":" ","version":null,"tagName":"h2"},{"title":"viewDocument​","type":1,"pageTitle":"Document Viewer API","url":"/docs/doc-viewer-api#viewdocument","content":" ▸ viewDocument(data): Promise&lt;null&gt;  Parameters​  Name\tTypedata\tViewDocumentOptions  Returns​  Promise&lt;null&gt; ","version":null,"tagName":"h3"},{"title":"Error handling","type":0,"sectionRef":"#","url":"/docs/errors","content":"","keywords":"","version":null},{"title":"Error codes​","type":1,"pageTitle":"Error handling","url":"/docs/errors#error-codes","content":" Both picker and viewer expose a errorCodes object which contains an object of possible error codes that can be returned by the native module.  Error codes are useful when determining which kind of error has occurred during the picking or viewing process.  Error Code Key\tDescriptionIN_PROGRESS\tThis is rather a warning, that happens when you invoke an operation (e.g. pick) while a previous one has not finished yet. For example: if you call pick() quickly twice in a row, 2 calls to pick() in the native module will be done. The first call will open the native document picker and user action will be expected. The promise from the second call to pick will be rejected with this error. Later, the first promise will resolve (or reject) with the actual files that the user has selected. Only one document picker window will be presented to the user. The reason the module explicitely rejects &quot;duplicated&quot; calls is to avoid memory leaks. UNABLE_TO_OPEN_FILE_TYPE\tWhen you try to open picker or viewer using a configuration that system cannot comply with. On Android, this is corresponds to ActivityNotFoundException. On iOS this only happens in the Viewer module when you attempt to preview a file that's not suppored by the QuickLook framework. OPERATION_CANCELED\tWhen user cancels the operation  note In a future release, OPERATION_CANCELED will be replaced with a more streamlined cancellation handling. We're keeping it now to make migration easier.  error-handling.ts import { errorCodes } from '@react-native-documents/picker' // or import { errorCodes } from '@react-native-documents/viewer' const handleError = (err: unknown) =&gt; { if (isErrorWithCode(err)) { switch (err.code) { case errorCodes.IN_PROGRESS: console.warn('user attempted to present a picker, but a previous one was already presented') break case errorCodes.UNABLE_TO_OPEN_FILE_TYPE: setError('unable to open file type') break case errorCodes.OPERATION_CANCELED: // ignore break default: setError(String(err)) console.error(err) } } else { setError(String(err)) } }   ","version":null,"tagName":"h3"},{"title":"isErrorWithCode(value)​","type":1,"pageTitle":"Error handling","url":"/docs/errors#iserrorwithcodevalue","content":" TypeScript helper to check if the passed parameter is an instance of Error which has the code property. All errors thrown by the picker and viewer modules have the code property, which contains a value from errorCodes or some other string for the less-usual errors.  isErrorWithCode can be used to avoid as casting when you want to access the code property on errors returned by the module.  import { pick, isErrorWithCode } from '@react-native-documents/picker' try { const [pickResult] = await pick() // do something with pickResult } catch (error) { if (isErrorWithCode(error)) { // here you can safely read `error.code` and TypeScript will know that it has a value } else { // this error does not have a `code`, and does not come from the native module } }  ","version":null,"tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":null},{"title":"What's new in the sponsor-only packages?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#whats-new-in-the-sponsor-only-packages","content":" Firstly, there's the completely new @react-native-documents/viewer package which is designed to work well together with the updated @react-native-documents/picker. The updated Picker module has an api very similar to the original, and contains the following improvements:  ","version":null,"tagName":"h2"},{"title":"TypeScript​","type":1,"pageTitle":"Introduction","url":"/docs/intro#typescript","content":" highly improved type definitions that make use of Discriminated Unions and other goodies so that you don't try to read fields that are not there. Works great with strict: true and noUncheckedIndexedAccess: true in your tsconfig (But these settings are not required! You can use vanilla JS too if you like.).mocks for testingpickSingle method was removed. You can instead use const [result] = pick()releaseSecureAccess was removed. I believe it's not necessary anymore because both the picker and the viewer module handle access in a way that does not require manual secure access management. Please open an issue if you need this method back.  ","version":null,"tagName":"h3"},{"title":"iOS​","type":1,"pageTitle":"Introduction","url":"/docs/intro#ios","content":" new: isKnownType utilitynew: support for long-term file access permissions - across app and even device reboots! (requestLongTermAccess)new: keepLocalCopy function that separates picking a file and copying it to a local directory. This makes your app more responsive: previously you'd use the copyTo option and before the resulting Promise resolved, you needed to wait not only for user to pick the file, but also for the file to be copied to your app's directory. For large files or with slow network, this could be a problem that you, as a dev don't see, but your users do.improved: the majority of the code is now written in Swift. The code is more readable and safer.improved: all the code on iOS would previously run on the main thread. Now, the suitable parts are handled on a background thread or using Swift's concurrency methods. You don't want to do file I/O on the main thread.improved: using the new UIDocumentPickerViewController apis instead of those deprecated in iOS 14improved: instead of the old copyTo parameter making unnecessary copies, the new keepLocalCopy function just moves the imported file.  ","version":null,"tagName":"h3"},{"title":"Android​","type":1,"pageTitle":"Introduction","url":"/docs/intro#android","content":" new: support for open modenew: support for virtual filesnew: support for long-term file access permissions - across app and even device reboots! (requestLongTermAccess)new: keepLocalCopy function that separates picking a file and copying it to a local directory. This makes your app more responsive: previously you'd use the copyTo option and before the resulting Promise resolved, you needed to wait not only for user to pick the file, but also for the file to be copied to your app's directory. For large files or with slow network, this could be a problem that you, as a dev don't see, but your users do.improved: replaced the Java code with Kotlin and made it cleanerimproved: I have removed the deprecated AsyncTask usage and replaced it with Kotlin Coroutines.improved: the code is better at operating with I/O, for example byte buffer use is replaced with a potentially much more efficient alternative from java.nioimproved: reading file metadata is more defensive and efficient because only the necessary columns are queried from ContentResolver. The native Android apis are full of calls that can return null or throw so extra care is taken to handle these cases.  ","version":null,"tagName":"h3"},{"title":"Windows​","type":1,"pageTitle":"Introduction","url":"/docs/intro#windows","content":" Windows is not supported at the moment. While there is Windows-related code in the public module, it's not maintained. If you are interested in Windows support, please let me know!  ","version":null,"tagName":"h3"},{"title":"How do I know it works?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#how-do-i-know-it-works","content":" With so many changes, you might wonder if the new package is stable - especially with Android because... well, we know Android 😜.  To prove the new code is solid, I have written an e2e test suite that covers the majority of the features:  import modeopen modeviewing files, including long-term permissions  The test suite focuses on Android, and was executed on real devices from Samsung, Google and Huawei, with Android versions ranging between 8 and 14. iOS tests were done manually on a real device with iOS 17.  As a result, I have greater confidence in the new package than in the old one!  ","version":null,"tagName":"h3"},{"title":"Why do I ask for sponsorship?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#why-do-i-ask-for-sponsorship","content":" I (vonovak) have been maintaining the original react-native-document-picker package more or less since 2020. The package has been used by thousands of devs, but I could see that it had a lot of issues. The codebase was old and there was a lot to improve.  on Nov 26, 2022 I opened an issue on the original package:  Hello, I'm the module maintainer and I'm looking for sponsors who would be willing to help fund migrating to new architecture and bringing new improvements to the module: removal of deprecated apisimprovements to the module apiIf interested, please see my GH sponsors. Thank you! ❤️  But I received very little support for this task - and I understand: why would a company or an individual spend money if they get nothing but a vague promise in return? If you follow me on Twitter, you know I occasionally rant about open source (un)sustainability.  In January 2024 I decided to rewrite the package from scratch and make it better! The new package has a new name: @react-native-documents/picker and is hosted on the Github packages npm registry - not the public npm registry, and it is available to sponsors.  While I was at it, I also created a new viewer package which is available to sponsors as well.  So how to make OSS sustainable? My take is this: rather than asking for support, I provide a full-featured package and ask for a fee in return. I believe that the new packages are worth it.  I'd like to thank my long-term GitHub sponsors Litentry, Callstack and Expo.  ","version":null,"tagName":"h2"},{"title":"Migrating from the old package​","type":1,"pageTitle":"Introduction","url":"/docs/intro#migrating-from-the-old-package","content":" See the migration guide - it's not difficult!  ","version":null,"tagName":"h2"},{"title":"Pre-requisites​","type":1,"pageTitle":"Introduction","url":"/docs/intro#pre-requisites","content":" See the installation page for the pre-requisites.  info The library works with native apis (document picker, file system, etc.) which are, in some cases, fundamentally different across platforms. We will point out platform-specific details as necessary. ","version":null,"tagName":"h2"},{"title":"Viewer module","type":0,"sectionRef":"#","url":"/docs/viewer","content":"","keywords":"","version":null},{"title":"How it works​","type":1,"pageTitle":"Viewer module","url":"/docs/viewer#how-it-works","content":"     AndroidiOS viewDocument uses Intent.ACTION_VIEW internally.  ","version":null,"tagName":"h3"},{"title":"View a document given a uri​","type":1,"pageTitle":"Viewer module","url":"/docs/viewer#view-a-document-given-a-uri","content":" Uri would come from the open or import modes of the document picker.  See more in the API reference  Uri Example.tsx import { viewDocument } from '@react-native-documents/viewer' return ( &lt;Button title=&quot;view the last imported file&quot; onPress={() =&gt; { const uriToOpen = 'file:///path/to/your/file' viewDocument({ uri: uriToOpen }).catch(handleError) }} /&gt; )   ","version":null,"tagName":"h3"},{"title":"View a document given a bookmark​","type":1,"pageTitle":"Viewer module","url":"/docs/viewer#view-a-document-given-a-bookmark","content":" bookmark would come from the open mode, with the requestLongTermAccess option set to true.  See more in the API reference  Bookmark Example.tsx import { viewDocument } from '@react-native-documents/viewer' return ( &lt;Button title=&quot;view the last imported file&quot; onPress={() =&gt; { const bookmark = '...' viewDocument({ bookmark }).catch(handleError) }} /&gt; )  ","version":null,"tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/install","content":"","keywords":"","version":null},{"title":"Sponsor-Only Version​","type":1,"pageTitle":"Installation","url":"/docs/install#sponsor-only-version","content":" Available only to GitHub sponsors, this version offers a ton of improvements over the public version. Full list of changes is here. To mention a few:  ✅ New: open mode on Android  ✅ New: keepLocalCopy function that separates picking a file and copying it to a local directory. This makes your app more responsive.  ✅ New: long-term file access permissions on both platforms  ... and much more  Your sponsorship enables continued maintenance and development of the module. Thank you for supporting this project! ❤️  ","version":null,"tagName":"h3"},{"title":"Public Version​","type":1,"pageTitle":"Installation","url":"/docs/install#public-version","content":" Available on the public npm registry, this version does not include the new features, updates and bugfixes found in the sponsor-only version.  ","version":null,"tagName":"h3"},{"title":"Accessing the private packages for sponsors​","type":1,"pageTitle":"Installation","url":"/docs/install#accessing-the-private-packages-for-sponsors","content":" Upon sponsoring (please use specifically the tiers that mention this project!), you will get immediate access * to the private packages and to the private monorepo with the sources and examples.  Three steps are needed to access the sponsored packages, which are hosted on GitHub npm packages registry.  Become a sponsor and accept private repository invitation * - it takes just a few clicks. Obtain here a Personal Access Token with packages:read permission. Set up your package manager so that it fetches the packages from the GH packages registry. In this example, we're using an NPM_TOKEN environment variable.      npm / yarn v1yarn v3+ create a .npmrc file in your project root with the following content: //npm.pkg.github.com/:_authToken=${NPM_TOKEN} @react-native-documents:registry=https://npm.pkg.github.com/   If you use another package manager (such as bun), please refer to its documentation on how to set up a custom registry.  ","version":null,"tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Installation","url":"/docs/install#requirements","content":" ","version":null,"tagName":"h2"},{"title":"Expo​","type":1,"pageTitle":"Installation","url":"/docs/install#expo","content":" warning This package cannot be used in the &quot;Expo Go&quot; app because it requires custom native code. However, you can add custom native code to expo by following the guide below. Read Expo's &quot;Adding custom native code&quot; guide for detailed information.  warning The document picker package requires iOS 14 or later. Use Expo build properties to update the deploymentTarget to 14.  ","version":null,"tagName":"h3"},{"title":"React Native​","type":1,"pageTitle":"Installation","url":"/docs/install#react-native","content":" The packages were tested with RN 0.73 but they most likely support older RN versions as well, all the way to 0.60.  The minimum required iOS version is iOS 14.0.  If you're using the New Architecture, you need to be on React Native 0.72 or higher.  ","version":null,"tagName":"h3"},{"title":"Installing​","type":1,"pageTitle":"Installation","url":"/docs/install#installing","content":" For sponsorsOriginal package yarn add @react-native-documents/picker yarn add @react-native-documents/viewer     Invitation Note​  As a sponsor, you will be added automatically if you sponsor from a personal account. If you sponsor from an organization account, please let me know and I'll add you manually. This is because of how GitHub handles this case. ","version":null,"tagName":"h2"},{"title":"Virtual files","type":0,"sectionRef":"#","url":"/docs/picker/virtual-files","content":"","keywords":"","version":null},{"title":"Obtaining regular file from a virtual file​","type":1,"pageTitle":"Virtual files","url":"/docs/picker/virtual-files#obtaining-regular-file-from-a-virtual-file","content":" If you want to export a virtual file into a local file, use the keepLocalCopy function and  double-check that the fileName parameter includes the extension.pass a mimeType value to the convertVirtualFileToType parameter.  Example.tsx &lt;Button title=&quot;import virtual file (such as a document from GDrive)&quot; onPress={async () =&gt; { const [file] = await pick({ allowVirtualFiles: true, }) const { name, uri: pickedUri, convertibleToMimeTypes } = file const virtualFileMeta = convertibleToMimeTypes &amp;&amp; convertibleToMimeTypes[0] invariant(name &amp;&amp; virtualFileMeta, 'name and virtualFileMeta is required') const [copyResult] = await keepLocalCopy({ files: [ { uri: pickedUri, fileName: `${name}.${virtualFileMeta.extension ?? ''}`, convertVirtualFileToType: virtualFileMeta.mimeType, }, ], destination: 'cachesDirectory', }) if (copyResult.status === 'success') { const localCopy = copyResult.localUri // do something with the local copy } }} /&gt;   For viewing or editing of virtual files you'll need to rely on the app that provided the virtual file (for example, Google Docs app for Google Docs files). The Document Viewer module can help you with that.  Learn more about virtual files in this video. ","version":null,"tagName":"h2"},{"title":"Limiting selectable file types","type":0,"sectionRef":"#","url":"/docs/picker/limiting-selectable-files","content":"","keywords":"","version":null},{"title":"isKnownType​","type":1,"pageTitle":"Limiting selectable file types","url":"/docs/picker/limiting-selectable-files#isknowntype","content":" isKnownType is a handy utility function that given one of:  UTType identifier stringMIME type stringFile extension string  tells you if the device recognizes it, and returns the corresponding MIME type, file extension, and UTType identifier.  import { isKnownType } from '@react-native-documents/picker' const { isKnown, mime, preferredFilenameExtension } = isKnownType({ kind: 'extension', value: 'pdf', })   This is currently only implemented on iOS, but it's useful on Android too: If your task is to allow selecting only some specific file type, you need to know what identifier (UTType on iOS, MIME type on Android) to use.  If you know the file extension (or the MIME, or the UTType), then use isKnownType to find the corresponding MIME type for Android or UTType for iOS.  warning Different devices, based on the installed apps, may recognize different file types.  ","version":null,"tagName":"h3"},{"title":"Predefined File Types​","type":1,"pageTitle":"Limiting selectable file types","url":"/docs/picker/limiting-selectable-files#predefined-file-types","content":" These are the most common file types, and are available in the types export. See the usage example above.  import { types } from '@react-native-documents/picker'   types.allFiles: All document types, on Android this is */*, on iOS it's public.itemtypes.images: All image typestypes.plainText: Plain text filestypes.audio: All audio typestypes.pdftypes.ziptypes.csvtypes.doctypes.docxtypes.ppttypes.pptxtypes.xlstypes.xlsx ","version":null,"tagName":"h3"},{"title":"Open mode","type":0,"sectionRef":"#","url":"/docs/picker/open-mode","content":"","keywords":"","version":null},{"title":"How it works​","type":1,"pageTitle":"Open mode","url":"/docs/picker/open-mode#how-it-works","content":"   AndroidiOS Open mode uses Intent.ACTION_OPEN_DOCUMENT internally.  ","version":null,"tagName":"h3"},{"title":"Open Options​","type":1,"pageTitle":"Open mode","url":"/docs/picker/open-mode#open-options","content":" Name\tType\tDescriptionmode\t'open'\tspecify that you want the picker to function in the &quot;open&quot; mode. type?\tstring | PredefinedFileTypes | (PredefinedFileTypes | string)[]\tspecify file type(s) that you want to pick. Use types for some predefined values. requestLongTermAccess?\tboolean\tWhether to ask for long-term access permissions. False by default. allowMultiSelection?\tboolean\tWhether to allow multiple files to be picked. False by default. allowVirtualFiles?\tboolean\tAndroid only - Whether to allow virtual files (such as Google docs or sheets) to be picked. False by default. presentationStyle?\tPresentationStyle\tiOS only - Controls how the picker is presented, e.g. on an iPad you may want to present it fullscreen. Defaults to pageSheet. transitionStyle?\tTransitionStyle\t  ","version":null,"tagName":"h3"},{"title":"Open result​","type":1,"pageTitle":"Open mode","url":"/docs/picker/open-mode#open-result","content":" The result is the same for both open and import modes.      note Many of the fields are nullable because the file metadata might not be available in some cases. While it's unlikely, it can happen especially on Android if a user picks a file from a Document Provider that doesn't make the information available.  Each picked file is an object with the following properties:  Name\tType\tDescriptionuri\tstring\tThe URI of the picked file. name\tstring | null\tThe name of the picked file, including the extension. size\tnumber | null\tThe size of the picked file in bytes. type\tstring | null\tThe MIME type of the picked file. error\tstring | null\tError in case the file metadata could not be obtained. isVirtual\tboolean | null\tAndroid-only: Whether the file is a virtual file (such as Google docs or sheets). convertibleToMimeTypes\tstring[] | null\tAndroid-only: The target types the virtual file can be converted to. Useful for keepLocalCopy. This field is only present if isVirtual is true, and only on Android 7.0+. nativeType\tstring | null\tThe &quot;native&quot; type of the picked file: on Android, this is the MIME type. On iOS, it is the UTType identifier.  ","version":null,"tagName":"h3"},{"title":"Long-term file access​","type":1,"pageTitle":"Open mode","url":"/docs/picker/open-mode#long-term-file-access","content":" When requestLongTermAccess is set to true, your app will be able to access the file even after the app is closed and reopened.  If you've requested long-term access to a directory or file, the response object will contain BookmarkingResponse.  In order to access the same directory or file in the future, you must check bookmarkStatus and store the bookmark opaque string. When you want to access the file again, you can use the bookmark to resolve the file uri. See the Document viewer source on how to do it, if you need this (advanced use case).  Example.tsx import { pick, types } from '@react-native-documents/picker' return ( &lt;Button title=&quot;open pdf file with requestLongTermAccess: true&quot; onPress={async () =&gt; { try { const [result] = await pick({ mode: 'open', requestLongTermAccess: true, type: [types.pdf], }) if (result.bookmarkStatus === 'success') { const bookmarkToStore = { fileName: result.name ?? 'unknown name', bookmark: result.bookmark, } localStorage.set('bookmark', JSON.stringify(bookmarkToStore)) } else { console.error(result) } } catch (err) { // see error handling } }} /&gt; )  ","version":null,"tagName":"h3"},{"title":"Import mode","type":0,"sectionRef":"#","url":"/docs/picker/import-mode","content":"","keywords":"","version":null},{"title":"How it works​","type":1,"pageTitle":"Import mode","url":"/docs/picker/import-mode#how-it-works","content":"   AndroidiOS Import mode uses Intent.ACTION_GET_CONTENT internally. In import mode, the returned uris are file references transient to your activity's current lifecycle. If you want to access a file later you must import a copy that you can read later, using keepLocalCopy, or use the open mode instead.  ","version":null,"tagName":"h3"},{"title":"Import Options​","type":1,"pageTitle":"Import mode","url":"/docs/picker/import-mode#import-options","content":" Name\tType\tDescriptiontype?\tstring | PredefinedFileTypes | (PredefinedFileTypes | string)[]\tspecify file type(s) that you want to pick. Use types for some predefined values. allowMultiSelection?\tboolean\tWhether to allow multiple files to be picked allowVirtualFiles?\tboolean\tAndroid only - Whether to allow virtual files (such as Google docs or sheets) to be picked. False by default. presentationStyle?\tPresentationStyle\tiOS only - Controls how the picker is presented, e.g. on an iPad you may want to present it fullscreen. Defaults to pageSheet. transitionStyle?\tTransitionStyle\tiOS only - Configures the transition style of the picker. Defaults to coverVertical, when the picker is presented, its view slides up from the bottom of the screen.  ","version":null,"tagName":"h3"},{"title":"Import result​","type":1,"pageTitle":"Import mode","url":"/docs/picker/import-mode#import-result","content":" The result of the pick function is an array of picked files (the result is the same for both open and import modes). The array has a length of 1 if allowMultiSelection is false (the default), and 1 or more if allowMultiSelection is true.      note Many of the fields are nullable because the file metadata might not be available in some cases. While it's unlikely, it can happen especially on Android if a user picks a file from a Document Provider that doesn't make the information available.  Each picked file is represented by an object with the following properties:  Name\tType\tDescriptionuri\tstring\tThe URI of the picked file. name\tstring | null\tThe name of the picked file, including the extension. It's very unlikely that it'd be null but in theory, it can happen. size\tnumber | null\tThe size of the picked file in bytes. type\tstring | null\tThe MIME type of the picked file. error\tstring | null\tError in case the file metadata could not be obtained. isVirtual\tboolean | null\tAndroid: Whether the file is a virtual file (such as Google docs or sheets). Will be null on pre-Android 7.0 devices. On iOS, it's always false. convertibleToMimeTypes\tstring[] | null\tAndroid: The target types the virtual file can be converted to. Useful for keepLocalCopy. This field is only present if isVirtual is true, and only on Android 7.0+. Always null on iOS. nativeType\tstring | null\tThe &quot;native&quot; type of the picked file: on Android, this is the MIME type. On iOS, it is the UTType identifier.  Please note that you might need to use decodeURIComponent in order to get the URI in the format you need for further processing, e.g. when using react-native-fs.  ","version":null,"tagName":"h3"},{"title":"Keeping a local copy of the picked files​","type":1,"pageTitle":"Import mode","url":"/docs/picker/import-mode#keepLocalCopy","content":" keepLocalCopy makes the file available in the app's storage. The behavior is different on iOS and Android:  AndroidiOS This method opens an InputStream pointing to the picked content:// uri and stores its bytes into a file. This file's location is determined by the destination parameter. It can be used to &quot;convert&quot; a content:// Uri into a local file. It also &quot;converts&quot; virtual files (such as Google docs or sheets) into local files.    note For each call of keepLocalCopy, a new unique directory is created in the app's storage, and the files are placed into it. This way, the files are isolated and subsequent calls to keepLocalCopy with the same file names do not overwrite the previous files. When writing to the filesystem, path traversal vulnerability is prevented. Writing files outside the intended destination will error.  Also note that for some common use cases, such as uploading the picked file to a server, you may not need to call keepLocalCopy. This will be clarified in a later docs update.  import { pick, keepLocalCopy } from '@react-native-documents/picker' return ( &lt;Button title=&quot;single file import, and ensure it is available in the local storage&quot; onPress={async () =&gt; { try { const [{ name, uri }] = await pick() const [copyResult] = await keepLocalCopy({ files: [ { uri, fileName: name ?? 'fallback-name', }, ], destination: 'documentDirectory', }) if (copyResult.status === 'success') { // do something } } catch (err) { // see error handling } }} /&gt; )  ","version":null,"tagName":"h3"},{"title":"Document Picker API","type":0,"sectionRef":"#","url":"/docs/doc-picker-api","content":"","keywords":"","version":null},{"title":"Type Aliases​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#type-aliases","content":" ","version":null,"tagName":"h2"},{"title":"BookmarkingResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#bookmarkingresponse","content":" Ƭ BookmarkingResponse: { bookmark: string ; bookmarkStatus: &quot;success&quot; } | { bookmarkError: string ; bookmarkStatus: &quot;error&quot; }  If you've requested long-term access to a directory or file, this object will be returned in the response. In order to access the same directory or file in the future, you must store the bookmark opaque string, and then pass it to the document viewer if you want to preview the file.  See the Document viewer source on how to retrieve the file from the bookmark, if you need to do that (advanced use case).    ","version":null,"tagName":"h3"},{"title":"FileToCopy​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#filetocopy","content":" Ƭ FileToCopy: Object  Parameter of keepLocalCopy. Object type representing the file(s) whose copy should be kept in the app's storage.  Type declaration​  Name\tType\tDescriptionconvertVirtualFileToType?\tstring\tOnly for Android virtual files: the type of the file to export to. For example, application/pdf or text/plain. Use one of the values from convertibleToMimeTypes from the response of the pick() method: DocumentPickerResponse. fileName\tstring\tthe name of the resulting file, with the file extension. You can use the name field from the response of the pick() method. Example: someFile.pdf uri\tstring\tThe uri to keep a local copy of. This would be a content:// uri (Android), or a file:// uri (iOS) that the user has previously picked.    ","version":null,"tagName":"h3"},{"title":"IsKnownTypeResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#isknowntyperesponse","content":" Ƭ IsKnownTypeResponse: Object  The result of calling isKnownType  Type declaration​  Name\tType\tDescriptionUTType\tstring | null\tthe UTType identifier for the given value, if any isKnown\tboolean\twhether the type is known to iOS mime\tstring | null\tthe mime type for the given value, if any preferredFilenameExtension\tstring | null\tthe preferred filename extension for the given value, if any    ","version":null,"tagName":"h3"},{"title":"KeepLocalCopyOptions​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#keeplocalcopyoptions","content":" Ƭ KeepLocalCopyOptions: Object  options for keepLocalCopy  Type declaration​  Name\tTypedestination\t&quot;cachesDirectory&quot; | &quot;documentDirectory&quot; files\tNonEmptyArray&lt;FileToCopy&gt;    ","version":null,"tagName":"h3"},{"title":"KeepLocalCopyResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#keeplocalcopyresponse","content":" Ƭ KeepLocalCopyResponse: NonEmptyArray&lt;LocalCopyResponse&gt;  Result of the call to keepLocalCopy. Please note the promise always resolves, even if there was an error processing any uri(s) (as indicated by the status field, and copyError field).    ","version":null,"tagName":"h3"},{"title":"LocalCopyResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#localcopyresponse","content":" Ƭ LocalCopyResponse: { localUri: string ; sourceUri: string ; status: &quot;success&quot; } | { copyError: string ; sourceUri: string ; status: &quot;error&quot; }  Indicates, for each Uri that was passed to keepLocalCopy, whether the local copy was successfully created or not.  If the copy was successful, the status field is success and localUri field will contain the local Uri. If the copy was not successful, the status field is error and copyError field will contain the error message.    ","version":null,"tagName":"h3"},{"title":"PredefinedFileTypes​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#predefinedfiletypes","content":" Ƭ PredefinedFileTypes: Flatten&lt;AllMimeTypes&gt; | AllAppleUTIs  You'd rarely use this type directly. It represents the predefined file types which are exported as types and can be used to limit the kinds of files that can be picked.  Example  import { pick, types, } from '@react-native-documents/picker' // ... const result = await pick({ type: [types.pdf, types.docx], })     ","version":null,"tagName":"h3"},{"title":"PresentationStyle​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#presentationstyle","content":" Ƭ PresentationStyle: &quot;fullScreen&quot; | &quot;pageSheet&quot; | &quot;formSheet&quot; | &quot;overFullScreen&quot; | undefined  iOS only. Configure the presentation style of the picker.    ","version":null,"tagName":"h3"},{"title":"TransitionStyle​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#transitionstyle","content":" Ƭ TransitionStyle: &quot;coverVertical&quot; | &quot;flipHorizontal&quot; | &quot;crossDissolve&quot; | &quot;partialCurl&quot; | undefined  iOS only. Configure the transition style of the picker.  ","version":null,"tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#variables","content":" ","version":null,"tagName":"h2"},{"title":"errorCodes​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#errorcodes","content":" • Const errorCodes: Readonly&lt;{ IN_PROGRESS: &quot;ASYNC_OP_IN_PROGRESS&quot; ; OPERATION_CANCELED: &quot;OPERATION_CANCELED&quot; ; UNABLE_TO_OPEN_FILE_TYPE: &quot;UNABLE_TO_OPEN_FILE_TYPE&quot; }&gt;  Error codes that can be returned by the module, and are available on the code property of the error.  Example   const handleError = (err: unknown) =&gt; { if (isErrorWithCode(err)) { switch (err.code) { case errorCodes.IN_PROGRESS: ... break case errorCodes.UNABLE_TO_OPEN_FILE_TYPE: ... break case errorCodes.OPERATION_CANCELED: // ignore break default: console.error(err) } } else { console.error(err) } }   ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#functions","content":" ","version":null,"tagName":"h2"},{"title":"isErrorWithCode​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#iserrorwithcode","content":" ▸ isErrorWithCode(error): error is NativeModuleError  TypeScript helper to check if an object has the code property. This is used to avoid as casting when you access the code property on errors returned by the module.  Parameters​  Name\tTypeerror\tany  Returns​  error is NativeModuleError  ","version":null,"tagName":"h3"},{"title":"DocumentPicker​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpicker","content":" ","version":null,"tagName":"h2"},{"title":"isKnownType​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#isknowntype","content":" ▸ isKnownType(«destructured»): IsKnownTypeResponse  This implemented on iOS only. Always returns { isKnown: false, preferredFilenameExtension: null, mime: null, UTType: null } on Android.  Checks if the given value (which can be a file extension, UTType identifier or mime) is known to the system. Such UTIs can be used with the document picker to filter what files can be picked. Also returns the mime type which you can use to filter files on Android.  Parameters​  Name\tType«destructured»\tIsKnownTypeOptions  Returns​  IsKnownTypeResponse    ","version":null,"tagName":"h3"},{"title":"keepLocalCopy​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#keeplocalcopy","content":" ▸ keepLocalCopy(options): Promise&lt;KeepLocalCopyResponse&gt;  Makes the file available in the app's storage. The behavior is different on iOS and Android, and for simple use cases (such as uploading file to remote server), you may not need to call this method at all.  On iOS, this method is not strictly necessary, as the file is already temporarily available (until the app quits) in a location in the app's sandbox when it is picked.keepLocalCopy is still useful if you need to prevent the file from being deleted by the system (by moving it to the app's Documents dir).  To do that, call keepLocalCopy() and pass destination: &quot;documentDirectory&quot;. This moves (= the file is moved, not copied, to prevent unnecessary duplicities) the file from the temporary location it is in when it is picked, into Documents directory, where the file lives until the app is uninstalled.  On Android, this method opens an InputStream pointing to the picked content:// uri and stores its bytes into a file. This file's location is determined by the destination parameter.  On Android, it can be used to &quot;convert&quot; a content:// Uri into a local file. It also &quot;exports&quot; virtual files (such as Google docs or sheets) into local files.  However, note that for some use cases, such as uploading the picked file to a server, you may not need to call keepLocalCopy at all. React Native's TODO can handle content:// uris.  Parameters​  Name\tTypeoptions\tKeepLocalCopyOptions  Returns​  Promise&lt;KeepLocalCopyResponse&gt;    ","version":null,"tagName":"h3"},{"title":"pick​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#pick","content":" ▸ pick&lt;O&gt;(options?): PickResponse&lt;O&gt;  The method for picking a file, both for import and open modes.  See DocumentPickerOptionsImport, DocumentPickerOptionsOpenOnce or DocumentPickerOptionsOpenLongTerm for the options you may want to pass to it.  Type parameters​  Name\tTypeO\textends DocumentPickerOptions  Parameters​  Name\tTypeoptions?\tO  Returns​  PickResponse&lt;O&gt;    ","version":null,"tagName":"h3"},{"title":"pickDirectory​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#pickdirectory","content":" ▸ pickDirectory&lt;O&gt;(options?): PickDirectoryResponse&lt;O&gt;  Opens a directory picker.  Type parameters​  Name\tTypeO\textends DirectoryPickerOptions  Parameters​  Name\tTypeoptions?\tO  Returns​  PickDirectoryResponse&lt;O&gt;  ","version":null,"tagName":"h3"},{"title":"pick() types​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#pick-types","content":" ","version":null,"tagName":"h2"},{"title":"DocumentPickerOptionsBase​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpickeroptionsbase","content":" Ƭ DocumentPickerOptionsBase: Object  Base options object for the document picker. You'd rarely use this type directly, but instead use one of  DocumentPickerOptionsImport, DocumentPickerOptionsOpenOnce or DocumentPickerOptionsOpenLongTerm  which extend this type  Type declaration​  Name\tType\tDescriptionallowMultiSelection?\tboolean\tWhether to allow multiple files to be picked. False by default. allowVirtualFiles?\tboolean\tAndroid only - Whether to allow virtual files (such as Google docs or sheets) to be picked. False by default. presentationStyle?\tPresentationStyle\tiOS only - Controls how the picker is presented, e.g. on an iPad you may want to present it fullscreen. Defaults to pageSheet. transitionStyle?\tTransitionStyle\tiOS only - Configures the transition style of the picker. Defaults to coverVertical, when the picker is presented, its view slides up from the bottom of the screen. type?\tstring | PredefinedFileTypes | (PredefinedFileTypes | string)[]\tspecify file type(s) that you want to pick. Use types for some predefined values.    ","version":null,"tagName":"h3"},{"title":"DocumentPickerOptionsImport​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpickeroptionsimport","content":" Ƭ DocumentPickerOptionsImport: DocumentPickerOptionsBase &amp; { mode?: &quot;import&quot; ; requestLongTermAccess?: never }  Present the document picker in import mode.    ","version":null,"tagName":"h3"},{"title":"DocumentPickerOptionsOpenLongTerm​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpickeroptionsopenlongterm","content":" Ƭ DocumentPickerOptionsOpenLongTerm: DocumentPickerOptionsBase &amp; { mode: &quot;open&quot; ; requestLongTermAccess: true }  Present the document picker in open mode, with long-term permissions to access the opened file.    ","version":null,"tagName":"h3"},{"title":"DocumentPickerOptionsOpenOnce​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpickeroptionsopenonce","content":" Ƭ DocumentPickerOptionsOpenOnce: DocumentPickerOptionsBase &amp; { mode: &quot;open&quot; ; requestLongTermAccess?: false }  Present the document picker in open mode, with permissions to access the file for a limited time (until the app terminates).    ","version":null,"tagName":"h3"},{"title":"DocumentPickerResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpickerresponse","content":" Ƭ DocumentPickerResponse: Object  Type declaration​  Name\tType\tDescriptionconvertibleToMimeTypes\tVirtualFileMeta[] | null\tAndroid: The target types the virtual file can be converted to. Useful for keepLocalCopy. This field is only present if isVirtual is true, and only on Android 7.0+. Always null on iOS. error\tstring | null\tError in case the file metadata could not be obtained. isVirtual\tboolean | null\tAndroid: whether the file is a virtual file (such as Google docs or sheets). Will be null on pre-Android 7.0 devices. On iOS, it's always false. name\tstring | null\tThe name of the picked file, including the extension. It's very unlikely that it'd be null but in theory, it can happen. nativeType\tstring | null\tThe &quot;native&quot; type of the picked file: on Android, this is the MIME type. On iOS, it is the UTType identifier. size\tnumber | null\tThe size of the picked file in bytes. type\tstring | null\tThe MIME type of the picked file. uri\tstring\tThe URI of the picked file.    ","version":null,"tagName":"h3"},{"title":"DocumentPickerResponseOpenLongTerm​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#documentpickerresponseopenlongterm","content":" Ƭ DocumentPickerResponseOpenLongTerm: DocumentPickerResponse &amp; BookmarkingResponse  The result of calling pick with mode: 'open' and requestLongTermAccess: true    ","version":null,"tagName":"h3"},{"title":"VirtualFileMeta​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#virtualfilemeta","content":" Ƭ VirtualFileMeta: Object  Type declaration​  Name\tType\tDescriptionextension\tstring | null\tThe registered extension for the given MIME type. Note that some MIME types map to multiple extensions. This call will return the most common extension for the given MIME type. Example: pdf mimeType\tstring\tthe MIME type of the file. This is necessary to export the virtual file to a local file. Example: application/pdf  ","version":null,"tagName":"h3"},{"title":"pickDirectory() types​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#pickdirectory-types","content":" ","version":null,"tagName":"h2"},{"title":"DirectoryPickerOptions​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#directorypickeroptions","content":" Ƭ DirectoryPickerOptions: DirectoryPickerOptionsBase &amp; { requestLongTermAccess: boolean }  Options for pickDirectory.    ","version":null,"tagName":"h3"},{"title":"DirectoryPickerOptionsBase​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#directorypickeroptionsbase","content":" Ƭ DirectoryPickerOptionsBase: Object  Base options object for the directory picker. They only slightly influence the appearance of the picker modal on iOS. You'd rarely use this type directly, but instead use DirectoryPickerOptions  which extend this type  Type declaration​  Name\tType\tDescriptionpresentationStyle?\tPresentationStyle\tiOS only - Controls how the picker is presented, e.g. on an iPad you may want to present it fullscreen. Defaults to pageSheet. transitionStyle?\tTransitionStyle\tiOS only - Configures the transition style of the picker. Defaults to coverVertical, when the picker is presented, its view slides up from the bottom of the screen.    ","version":null,"tagName":"h3"},{"title":"DirectoryPickerResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#directorypickerresponse","content":" Ƭ DirectoryPickerResponse: Object  This object represents the response from the directory picker, when long-term access was not requested.  Type declaration​  Name\tType\tDescriptionuri\tstring\tThe directory selected by user    ","version":null,"tagName":"h3"},{"title":"DirectoryPickerResponseLongTerm​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#directorypickerresponselongterm","content":" Ƭ DirectoryPickerResponseLongTerm: DirectoryPickerResponse &amp; BookmarkingResponse  This object represents the response from the directory picker, when long-term access was requested.    ","version":null,"tagName":"h3"},{"title":"PickDirectoryResponse​","type":1,"pageTitle":"Document Picker API","url":"/docs/doc-picker-api#pickdirectoryresponse","content":" Ƭ PickDirectoryResponse&lt;O&gt;: Promise&lt;O extends DirectoryPickerOptionsLongTerm ? DirectoryPickerResponseLongTerm : DirectoryPickerResponse&gt;  You likely won't use this type directly, but instead use DirectoryPickerResponse or DirectoryPickerResponseLongTerm.  Type parameters​  Name\tTypeO\textends DirectoryPickerOptions ","version":null,"tagName":"h3"}],"options":{"disableVersioning":true,"excludeRoutes":["/docs/license"],"id":"default"}}